---
layout: post
title: ES6의 유용한 문법 정리
subtitle: ES6 문법으로 더 간편하고 직관적으로 코딩할 수 있는 방법을 정리
#cover-img: /assets/img/path.jpg
#thumbnail-img: /assets/img/thumb.png
#share-img: /assets/img/path.jpg
#tags: [books, test]
---

# ES6 정리

## 1. let, const

### - 특징
- `var`이 가진 문제
  - 함수 스코프
    - `var`은 함수스코프이기 때문에 for 반복문에서 정의된 변수가 반복문이 끝난 이후에도 남아 있다.
    ````javascript
    for(var i = 0 ; i < 10; i++) {
      console.log(i)
    }
    console.log(i); // 10
    ````
  - 호이스팅
    - 보통의 프로그래밍 언어와 달리 첫번째 줄의 val 출력이 에러가 발생할 것 같지만 에러없이 동작한다. 직관적이지 않음
    ````javascript
    console.log(val);  //undefined
    val = 2;
    console.log(val);   // 2
    var val = 1;
    ````

- `var`의 문제를 해결하는 `const, let`
  - `const, let`은 블록 스코프
    - 블록안에서 선언한 변수는 블록안에서만 사용가능
    ````javascript
    for(var i = 0 ; i < 10; i++) {
      console.log(i)
    }
    console.log(i); // error 발생. i가 선언되어 있지 않음
    ````

  - 호이스팅
    - 호이스팅은 발생하지만 선언되기전에 사용되면 에러가 발생
    ````javascript
    console.log(foo); // error 발생
    const foo = 1;
    ````
    - 주의사항: console.log() 부분에서 1이 블록스코프 밖의 `foo`변수를 참조할것 같지만 블록스코프 내에 `foo`변수 선언으로 인해 호이스팅이 발생하고 console.log에서 사용하므로 에러가 발생한다.
    ````javascript
    const foo = 1;
    {
      console.log(foo); // 참조 에러
      const foo = 2;
    }
    ````

- `const`는 재할당 불가능한 변수를 만들수 있다.
  ````javascript
  const bar = 'a';
  bar = 'b'; // 에러 발생
  ````


## 2. 객체와 배열의 사용성 개선

- 단축속성명(shorthand property names)
````javascript
const name = 'jeon';
const obj = {
  age: 31,
  name,  // name: name
  getName() { return this.name } //getName : function() { ... }
}
````

-계산된 속성명(computed property names)
````javascript
//동적인 속성명 사용가능
function createObj(key, value) {
  return { [key]: value }; // const obj = {}, obj[key] = value, return obj
}
````

- 전개 연산자(spread operator) 
````javascript
Math.max(1, 2, 3, 4); // 각각의 파라미터 입력 필요
const arr = [1, 2, 3, 4];
Math.max(...arr); // ...arr => 1, 2, 3, 4

const obj = { a: 'a' };

const arr2 = [...arr] //배열 복사
const obj2 = { ...obj } //객체 복사

[1, ...[2, 3], 4]; //전후 순서 유지

//객체 병합
const obj3 = { a: 'a', b: 'b' };
const obj4 = { b: 'c' };
const obj5 = { ...obj3, ...obj4 }; // { a: 'a', b: 'c' }, 중복될경우 마지막 속성 사용
````

- 배열 비구조화(array destructuring)
```` javascript
const arr = [1, 2];
const [a, b] = arr; // a = 1, b = 2

let a, b;
[a, b] = [1, 2]; // a = 1, b = 2

//기본값 설정
const arr = [1];
const [a = 10, b = 20] = arr; // a = 1, b = 20

//속성값 건너뛰기
const arr = [1 ,2, 3];
const [a, ,c] = arr; // a = 1, c = 3

//나머지값 배열로
const arr = [1, 2, 3];
const [a, ...arr2] = arr; // a = 1, arr2 = [2, 3];
````

- 객체 비구조화(object destructuring)
```` javascript
//배열 비구조화와 비교하여 배열은 순서가 중요하고 객체는 속성명이 중요
const obj = { a: 'a', b: 'b' };
const { a, b } = obj;  // a = 'a', b = 'b'

//별칭 사용하기
const { a: _a, b } = obj;  // _a = 'a', b = 'b'

//기본값 설정
const { a = '1', c = 'c' } = obj;  // a = 'a', c = 'c'

//기본값 별칭 동시 사용
const { a: _a = '1', c = 'c' } = obj;  // _a = 'a', c = 'c'

//함수 기본값
function defaultFunc() {
  console.log('invoke');
  return 0;
}
const { a = defaultFunc(), b } = obj; // a = 'a', b = 'b'  - 'invoke' 호출되지 않음
//함수 기본값은 기본값으로 쓰일때만 실행이 된다

//나머지
const obj2 = { a: 'a', b: 'b', c: 'c'};
const { a, ...obj3 } = obj2;  // a = 'a', obj3 = { b: 'b', c: 'c' }

//for문에서 객체 비구조화 사용
const arr = [ { a: 'a', b: 'b' }, { a: 'a1', b: 'b1' } ];
for ( const { a, b } of arr ) {
  //... a, b 변수 사용
}
````

- 비구조화의 심화
````javascript
const obj = { name: 'mike', mother: { name: 'sara' } };
const { name, mother: {name: motherName } }; // name = 'mike', motherName = 'sara'

const index = 1;
const { [`key${index}`]: valueOfTheIndex } = { key1: 123 }; // valueOfTheIndex = 123  - 계산된속성명을 사용할경우 별칭을 사용해야함
````


## 함수의 기능
````javascript
function printLog(a = 1) {
  console.log(a); 
}
printLog(); // print 1

//함수 기본값
function defaultFunc() { return 0; }
function printLog(a = defaultFunc()) {
  console.log(a);
}
printLog(); // print 1

//필수값 표현
function required() {
  throw new Error('no parameter');
}
function printLog(a = required()) {
  console.log(a);
}
printLog(); // print 1

//나머지 매개변수
function printLog(a, ...rest) {
  console.log({ a, rest });
}
printLog(1, 2, 3); // { a: 1, b: [2, 3] }

//화살표 함수(arrow function)
const add = (a, b) => a + b; // function(a, b) { return a + b; }
const add5 = a => a + 5; // function(a) { return a + 5; }
const addAndReturnObject = (a, b) => ({ result: a + b }); // function(a, b) { return { a + b };}

//화살표 함수. 여러줄일 경우
const add = (a, b) => {
  return a + b;
} // function(a, b) { return a + b; }

// * 특징
// this와 arguments 가 바인딩 되지 않는다.

// this의 주의점
const obj = {
  value: 1,
  increase: function() {
    this.value++;
  }
}
const increase = obj.increase;
increase() // obj.value = 1  - this는 window 객체를 참조하므로 obj.value는 증가하지 않음

function Constr() {
  this.value = 1;
  this.increase = () => this.value++;
}
const obj = new Constr();
const increase = obj.increase;
increase() // obj.value = 2  - this는 항상 obj객체를 참조하고 있음. 
           // 그러므로 obj.value 증가 (* this는 호출시점의 this를 바인딩한다.)
````

## 프로미스(Promise)

- 비동기상태를 값으로 다룰 수 있는 객체

